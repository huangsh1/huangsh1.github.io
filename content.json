{"meta":{"title":"H·stone","subtitle":"hahaha","description":"blog","author":"H·stone","url":"http://huangshi.im","root":"/"},"pages":[{"title":"","date":"2021-05-26T05:00:46.812Z","updated":"2021-05-26T05:00:46.812Z","comments":true,"path":"about/index.html","permalink":"http://huangshi.im/about/index.html","excerpt":"","text":"个人简介一个普通男青年相信尘埃里会开出一朵花"}],"posts":[{"title":"grequsets源码解读","slug":"grequests","date":"2021-09-06T10:29:15.000Z","updated":"2021-09-11T01:37:48.679Z","comments":true,"path":"2021/09/06/grequests/","link":"","permalink":"http://huangshi.im/2021/09/06/grequests/","excerpt":"","text":"Grequests源码解读很简单的封装，主要还是request 和 gevent。协程以后应该好好看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#grequests#~~~~~~~~~#这个模块包含一个&#39;requests.api&#39;异步副本，通过gevent启动，所有API方法都返回一个&#96;&#96;Request&#96;&#96;实例（与&#96;&#96;Response&#96;&#96;相对），请求列表可以通过&#96;&#96;map（）发送&#96;&#96;.from functools import partialimport tracebacktry: import gevent from gevent import monkey as curious_george from gevent.pool import Poolexcept ImportError: raise RuntimeError(&#39;Gevent is required for grequests.&#39;)# Monkey-patch.curious_george.patch_all(thread&#x3D;False, select&#x3D;False)from requests import Session__all__ &#x3D; ( &#39;map&#39;, &#39;imap&#39;, &#39;get&#39;, &#39;options&#39;, &#39;head&#39;, &#39;post&#39;, &#39;put&#39;, &#39;patch&#39;, &#39;delete&#39;, &#39;request&#39;)class AsyncRequest(object): &quot;&quot;&quot; 异步请求. 接受与&#96;&#96;Session.request&#96;&#96;相同的参数，还有一些附加的参数: :param session: 发送请求的session :param callback: 响应时调用回调，类似传递 &#96;&#96;hooks&#x3D;&#123;&#39;response&#39;: callback&#125;&#96;&#96; &quot;&quot;&quot; def __init__(self, method, url, **kwargs): #: Request method self.method &#x3D; method #: URL to request self.url &#x3D; url #: Associated &#96;&#96;Session&#96;&#96; self.session &#x3D; kwargs.pop(&#39;session&#39;, None) if self.session is None: self.session &#x3D; Session() self._close &#x3D; True else: self._close &#x3D; False # 如果用户提供了会话，则不要在每次请求后关闭适配器 callback &#x3D; kwargs.pop(&#39;callback&#39;, None) if callback: kwargs[&#39;hooks&#39;] &#x3D; &#123;&#39;response&#39;: callback&#125; #: The rest arguments for &#96;&#96;Session.request&#96;&#96; self.kwargs &#x3D; kwargs #: Resulting &#96;&#96;Response&#96;&#96; self.response &#x3D; None def send(self, **kwargs): &quot;&quot;&quot; 根据传递给构造函数的参数和可选的“kwargs”准备请求。 然后发送请求并将响应保存到：attr:&#96;response&#96; :returns: &#96;&#96;Response&#96;&#96; &quot;&quot;&quot; merged_kwargs &#x3D; &#123;&#125; merged_kwargs.update(self.kwargs) merged_kwargs.update(kwargs) try: self.response &#x3D; self.session.request(self.method, self.url, **merged_kwargs) except Exception as e: self.exception &#x3D; e self.traceback &#x3D; traceback.format_exc() finally: if self._close: # 如果我们提供了会话对象，请确保我们正在清理 # 因为如果它不被重复使用，在这个时候保持它的开放是没有意义的 self.session.close() return selfdef send(r, pool&#x3D;None, stream&#x3D;False): &quot;&quot;&quot; 如果没有pool指定此方法，使用指定的pool发送请求对象。pool是非常好用的，因为你可以指定pool的大小，所以可以限制并发. &quot;&quot;&quot; if pool is not None: return pool.spawn(r.send, stream&#x3D;stream) return gevent.spawn(r.send, stream&#x3D;stream)# 使用适当的HTTP方法创建AsyncRequest的快捷方式get &#x3D; partial(AsyncRequest, &#39;GET&#39;)options &#x3D; partial(AsyncRequest, &#39;OPTIONS&#39;)head &#x3D; partial(AsyncRequest, &#39;HEAD&#39;)post &#x3D; partial(AsyncRequest, &#39;POST&#39;)put &#x3D; partial(AsyncRequest, &#39;PUT&#39;)patch &#x3D; partial(AsyncRequest, &#39;PATCH&#39;)delete &#x3D; partial(AsyncRequest, &#39;DELETE&#39;)# 同义词def request(method, url, **kwargs): return AsyncRequest(method, url, **kwargs)def map(requests, stream&#x3D;False, size&#x3D;None, exception_handler&#x3D;None, gtimeout&#x3D;None): &quot;&quot;&quot;同时将请求列表转换为响应. :param requests: 请求对象的集合. :param stream: 如果为True，则不会立即下载内容. :param size: 指定一次要发出的请求数. 如果没有，则不会发生限流. :param exception_handler: Callback function, 发生异常时调用，参数：请求，异常 :param gtimeout: Gevent joinall timeout in seconds. (Note: 与请求超时无关) &quot;&quot;&quot; requests &#x3D; list(requests) pool &#x3D; Pool(size) if size else None jobs &#x3D; [send(r, pool, stream&#x3D;stream) for r in requests] gevent.joinall(jobs, timeout&#x3D;gtimeout) ret &#x3D; [] for request in requests: if request.response is not None: ret.append(request.response) elif exception_handler and hasattr(request, &#39;exception&#39;): ret.append(exception_handler(request, request.exception)) elif exception_handler and not hasattr(request, &#39;exception&#39;): ret.append(exception_handler(request, None)) else: ret.append(None) return retdef imap(requests, stream&#x3D;False, size&#x3D;2, exception_handler&#x3D;None): &quot;&quot;&quot;同时将请求生成器对象转换为响应生成器. :param requests: 请求对象的生成器. :param stream: 如果为True，则不会立即下载内容. :param size: 指定一次要发出的请求数。默认值为2 :param exception_handler: Callback function, 发生异常时调用，参数：请求，异常 &quot;&quot;&quot; pool &#x3D; Pool(size) def send(r): return r.send(stream&#x3D;stream) for request in pool.imap_unordered(send, requests): if request.response is not None: yield request.response elif exception_handler: ex_result &#x3D; exception_handler(request, request.exception) if ex_result is not None: yield ex_result pool.join()","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://huangshi.im/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}],"author":"H·stone"},{"title":"grequsets做负载测试总结","slug":"test_fuzai","date":"2021-09-06T10:29:15.000Z","updated":"2021-09-06T10:33:27.836Z","comments":true,"path":"2021/09/06/test_fuzai/","link":"","permalink":"http://huangshi.im/2021/09/06/test_fuzai/","excerpt":"","text":"场景需求：优版权平台流量快速增长，抢购流量太大服务器崩溃导致用户投诉。随即开展负载测试，以便研发优化系统性能瓶颈。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&quot;&quot;&quot;1.准备账号数据 txt格式，里面账号形成列表 前提要求：账号登录密码，支付密码 666666 余额充足2.账号数据形成列表 以便脚本遍历3.遍历列表 生成data数据和 headers数据4.grequest并发访问发送请求&quot;&quot;&quot;import grequestsimport requestsimport jsonimport timefrom random import choicedef get_headers(): &quot;&quot;&quot; 随机获取请求头，后端对请有做限制 :return: &quot;&quot;&quot; file &#x3D; open(&#39;user_agent.txt&#39;, &#39;r&#39;) user_agent_list &#x3D; file.readlines() user_agent &#x3D; str(choice(user_agent_list)).replace(&#39;\\n&#39;, &#39;&#39;) user_agent &#x3D; &#39;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:39.0) Gecko&#x2F;20100101 Firefox&#x2F;39.0&#39; if len( user_agent) &lt; 10 else user_agent headers &#x3D; &#123; &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;User-Agent&quot;: user_agent &#125; return headersdef get_token(count): &quot;&quot;&quot; 获取账号token，随机了个请求头（可用可不用） :param count: :return: &quot;&quot;&quot; headers &#x3D; get_headers() data &#x3D; &#123; &quot;user&quot;: f&quot;&#123;count&#125;&quot;, &quot;password&quot;: &quot;f379eaf3c831b04de153469d1bec345e&quot;&#125; url &#x3D; &#39;https:&#x2F;&#x2F;test.ubanquan.cn&#x2F;登录接口&#39; response &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;json.dumps(data)) response &#x3D; json.loads(response.text) token &#x3D; response[&#39;data&#39;][&#39;token&#39;] userid &#x3D; response[&#39;data&#39;][&#39;userId&#39;] return token, useriddef noid(key): &quot;&quot;&quot; 获取专题的相关的 数据 :param key: :return: &quot;&quot;&quot; url &#x3D; &#39;https:&#x2F;&#x2F;test.h5.ubanquan.cn&#x2F;专题详情接口&#39; data &#x3D; &#123;&quot;themeKey&quot;: f&quot;&#123;key&#125;&quot;, &quot;userId&quot;: &quot;788802238600001623927428&quot;&#125; headers &#x3D; &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot; &#125; response &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;json.dumps(data)) response &#x3D; json.loads(response.text) assetsNo &#x3D; response[&#39;data&#39;][&#39;assetsNo&#39;] id &#x3D; response[&#39;data&#39;][&#39;id&#39;] return assetsNo, iddef header(count): &quot;&quot;&quot; 生成headers数据 :param count: :return: &quot;&quot;&quot; token, userid &#x3D; get_token(count) headers &#x3D; &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: f&#39;&#123;token&#125;&#39; &#125; return headers, useriddef read_phone(): &quot;&quot;&quot; 所有账号放在 一个txt文件夹中，读取成一个列表 :return: &quot;&quot;&quot; file &#x3D; open(&#39;all_phone.txt&#39;, &#39;r&#39;) colist &#x3D; file.read() phone_list &#x3D; eval(colist) file.close() print(&quot;已读取到全部的账号数据&quot;) return phone_listdef package_data(allcount_num): &quot;&quot;&quot; 组装数据 形成访问数据 :param allcount_num: :return: &quot;&quot;&quot; key &#x3D; &#39;key_olkiwnd&#39; data_list &#x3D; [] phone_list &#x3D; read_phone() assetsNo, id &#x3D; noid(key) for i in range(allcount_num): phone &#x3D; phone_list[i] try: token, userid &#x3D; get_token(phone) item &#x3D; &#123;&quot;data&quot;: &#123;&quot;assetsNo&quot;: f&quot;&#123;assetsNo&#125;&quot;, &quot;id&quot;: id, &quot;price&quot;: 100, &quot;quantity&quot;: &quot;1&quot;, &quot;themeKey&quot;: f&quot;&#123;key&#125;&quot;, &quot;totalAmount&quot;: 100, &quot;trueAmount&quot;: 100, &quot;useCouponCodeList&quot;: [], &quot;userId&quot;: f&quot;&#123;userid&#125;&quot;, &quot;tradePassword&quot;: &quot;f379eaf3c831b04de153469d1bec345e&quot;&#125;, &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: f&#39;&#123;token&#125;&#39; &#125;&#125; data_list.append(item) except: continue print(&#39;请求数据准备完毕，开始并发&#39;) return data_listdef err_handler(request, exception): &quot;&quot;&quot; grequests异常捕获 :param request: :param exception: :return: &quot;&quot;&quot; print(&quot;请求出错,当前购买失败&quot;)def main(timenum, allcount_num): &quot;&quot;&quot; 通过grequests执行并发主函数 :param timenum: :param allcount_num: :return: &quot;&quot;&quot; start &#x3D; time.time() data_list &#x3D; package_data(allcount_num) for i in range(timenum): response_list &#x3D; [] req_list &#x3D; [grequests.post(&#39;https:&#x2F;&#x2F;test.h5.ubanquan.cn&#x2F;被测抢购接口&#39;, data&#x3D;json.dumps(item[&#39;data&#39;]), headers&#x3D;item[&#39;headers&#39;], timeout&#x3D;30) for item in data_list] all_req_list &#x3D; grequests.map(req_list, exception_handler&#x3D;err_handler) for p in all_req_list: if p is not None: print(p.text) response_list.append(p.text) with open(f&#39;response&#123;i&#125;.txt&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: f.write(str(response_list)) flow_time &#x3D; i + 1 #次数 print(f&#39;第&#123;flow_time&#125;次压测请求完成&#39;) print(&#39;压测总运行时间：&#39;) print(time.time() - start)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: timenum &#x3D; 1 # 并发次数 allcount_num &#x3D; 700 # 并发用户数 main(timenum, allcount_num)","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://huangshi.im/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}],"author":"H·stone"},{"title":"总结工作中一些有用到比较有用的工具函数（二）","slug":"tools_two","date":"2021-09-02T04:00:15.000Z","updated":"2021-09-02T04:00:39.277Z","comments":true,"path":"2021/09/02/tools_two/","link":"","permalink":"http://huangshi.im/2021/09/02/tools_two/","excerpt":"","text":"YAML JSON 基于jsonpath对数据的读取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&quot;&quot;&quot;@classmethod 可以作为一种媒介，让我们更方便的操纵Python为class内置的一些属性和方法,也可以不需要实例化就能调用类中的方法1.【readYaml】功能 提供根据yaml文件名，读取yaml文件内容转化为字典格式的2.【jpathRead】功能 提供通过dict，jsonpath表达式，获取yaml文件value功能的3.【readJson】功能 提供根据json文件名，读取json文件内容&quot;&quot;&quot;import yamlimport jsonimport jsonpathfrom tools import findPathfrom commom.log import MyLogclass Readfile: @classmethod def readYaml(cls, yamlName): &quot;&quot;&quot; 根据yaml文件名，读取yaml文件内容转化为字典格式 :param config_path:默认取config文件夹下config.yaml :return:dict类型文档 &quot;&quot;&quot; config_path &#x3D; findPath(yamlName) with open(config_path, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as file: config_dict &#x3D; yaml.load(file.read(), Loader&#x3D;yaml.FullLoader) return config_dict @classmethod def jpathRead(cls, dict, exp): &quot;&quot;&quot; 根据传入的dict格式内容，和jsonpath表达式，return 取到的值，并且从列表中提取出来 :param dict:字典格式 :param exp:jsonpath表达式 :return: &quot;&quot;&quot; try: res &#x3D; jsonpath.jsonpath(dict, exp)[0] # jsonpath读取数据后返回的是一个列表 except Exception as e: MyLog.info(f&quot;jpathRead提取value时，读取数据错误，dict为：&#123;dict&#125;&quot;) res &#x3D; exp return res @classmethod def readJson(cls, jsonName): &quot;&quot;&quot; 根据json文件名，读取json文件内容转化为字典格式 :param jsonName: :return: &quot;&quot;&quot; config_path &#x3D; findPath(jsonName) with open(config_path, encoding&#x3D;&#39;UTF-8&#39;) as f: data &#x3D; json.load(f) return dataif __name__ &#x3D;&#x3D; &#39;__main__&#39;: re &#x3D; Readfile() res &#x3D; Readfile.readYaml(&#39;headers.yaml&#39;) ress &#x3D; re.jpathRead(res, &#39;$..ubq_ba&#39;) print(ress)","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://huangshi.im/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"工具函数","slug":"工具函数","permalink":"http://huangshi.im/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"}],"author":"H·stone"},{"title":"总结工作中一些有用到比较有用的工具函数（一）","slug":"tools_one","date":"2021-09-02T03:38:15.000Z","updated":"2021-09-02T03:45:31.877Z","comments":true,"path":"2021/09/02/tools_one/","link":"","permalink":"http://huangshi.im/2021/09/02/tools_one/","excerpt":"","text":"传入文件名，返回该文件在当前项目中的绝对路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&quot;&quot;&quot;1.提供findPath功能，传入文件名返回它在当前项目中绝对路径&quot;&quot;&quot;import osdef findPath(fileName): &quot;&quot;&quot; 查询并确定文件工具函数，通过传入文件名，直接返回文件的绝对路径（本工具函数的局限性是正对当前项目做了文件过滤） :param fileName: :return: &quot;&quot;&quot; for filepath in fileList(): path &#x3D; os.path.join(os.path.dirname(os.getcwd()), filepath) for root, dirs, files in os.walk(path): if fileName in files: expPath &#x3D; os.path.join(path, fileName) return expPathdef fileList(): &quot;&quot;&quot; 获取项目路径，查询全部文件夹，返回判断被需要的文件夹名列表 :return:一个文件包名字组成的列表 &quot;&quot;&quot; dirs &#x3D; [] path &#x3D; os.path.dirname(os.getcwd()) for root, dirs, files in os.walk(path): if dirs is not None: dirs &#x3D; dirs break file_list &#x3D; list(filter(jud, dirs)) # filter(判断函数, 被判断列表) return file_listdef jud(s): &quot;&quot;&quot; 对文件名做字符串判断，提供给filter功能调用 （局限项）通过修改jud函数可以拓展当前功能 :param s: :return: &quot;&quot;&quot; if &#39;__&#39; in s: return False if &#39;.&#39; in s: return False if &#39;allure&#39; in s: return False if &#39;log&#39; in s: return False if &#39;venv&#39; in s: return False return Trueif __name__ &#x3D;&#x3D; &#39;__main__&#39;: paht &#x3D; findPath(&#39;config.json&#39;) print(paht)》》》C:\\Users\\Administrator\\Desktop\\Api_autotest\\config\\config.json","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://huangshi.im/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"工具函数","slug":"工具函数","permalink":"http://huangshi.im/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"}],"author":"H·stone"},{"title":"QA的军火库","slug":"tools","date":"2021-06-21T10:25:30.000Z","updated":"2021-09-02T06:03:14.633Z","comments":true,"path":"2021/06/21/tools/","link":"","permalink":"http://huangshi.im/2021/06/21/tools/","excerpt":"","text":"python项目部署服务器：https://www.jianshu.com/p/063e2a784997?utm_campaign 目前可用的python-微信机器人：wechat_pc_api 文件转换的网站：https://convertio.co/zh/ pycharm的激活码获取：http://vrg123.com/ 如何迁移hexo博客：https://blog.csdn.net/weixin_42456056/article/details/108010568 如何迁移hexo博客：https://blog.csdn.net/qq_34187711/article/details/88592760?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"工具相关","slug":"工具相关","permalink":"http://huangshi.im/tags/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"}],"author":"H·stone"},{"title":"什么事情是你注重养生以后才知道的","slug":"yangsheng","date":"2021-05-07T03:20:30.000Z","updated":"2021-05-28T08:06:32.383Z","comments":true,"path":"2021/05/07/yangsheng/","link":"","permalink":"http://huangshi.im/2021/05/07/yangsheng/","excerpt":"","text":"1234作者：匿名用户链接：https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;451372641&#x2F;answer&#x2F;1843688807来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 也不是养生才知道的。就是得病知道的。 第一点不要熬夜，如果熬夜请尽量早点睡，不要觉得自己年轻牛逼，身体可以随便造。如果你能规律睡眠，植物神经紊乱会离你很远。一个人睡眠不会出问题，因为不熬夜。如果熬夜基本分四个阶段。第一阶段，你并不会因为熬夜觉得身体体力跟不上睡不好。第二阶段你熬夜觉得晚上睡的早了睡不着，早上起不来。第三阶段晚上睡一会就醒，白天睡得很香。第四阶段植物神经紊乱。无论白天晚上都睡不着。 第二点，不要生气，尤其生很大的气，不要因为别人的错误来惩罚自己，这句话说的很简单，但是做到很难。生气会和我一样肝风内动，导致高血压。 第三点，不要纵欲。不要纵欲，不要纵欲。1不干净，2纵欲过度导致肾虚，3多干点别的排解欲望。别等到肾虚了，头发掉了秃头了在后悔。肾虚的人往往欲望大，因为肾气一恢复你就有欲望。但是如果过了恢复阶段，往往欲望小了，身体也好了。越虚越想这是个恶性循环。 第四点，不要贪凉，贪凉容易导致你身体经常怕冷。 第五点，不要一直吃重油重盐的食物，偶尔吃一吃可以，一直吃容易动脉粥样硬化，血压高。老了很麻烦。多吃水果和蔬菜。尽量少吃含有反式脂肪的东西这些东西很不健康。 第六点，规律锻炼，不要赖床，赖床导致身体没有精神，不规律锻炼容易让你血压波动太明显，要么高压高，要么低压低，锻炼不是说让你慢跑，你可以选择任何让你觉得累的方式，只要你喜欢。高压高的感觉是脑袋晕但是胀的晕。低压低的感觉是身体莫名奇妙的累，喘不上气，有或者没有头晕。低压高的感觉也是胀的头晕。但是没有高压高，胀的那么明显。高血压患者不建议做俯卧撑，在医生指导下进行。 第七点，不要长时间盯着屏幕，偶尔45分钟放松一两分钟，你的眼睛会舒服的多。 第八点，养身体需要吃点中药，如果只是自然恢复很慢，像我起码得一两年。吃什么找好的中医把脉。 第九点，情绪尽量平稳。不要太过于生气怨恨贪心。对身体不好。 第十点，要睡好觉，睡不好觉真的不行，可以吃点中药调理，实在没办法也可以吃西药。 第一十点，不要为难自己，不要总是觉得难过，不要想的太多，不要总是沉浸在过去，要放眼未来，生活中快乐的事很多。 第十二点，远离那些会让你生病的人。有些人你和他在一起就会生病，你也不知道为什么，但是就是这样的。 第十三点，让自己快乐，忘记那些不愉快的事情，让自己活的快乐。 第十四点，如果脚冷可以每晚热水泡脚。这对改善睡眠真的有用。 第十五点，有些病西医可能没用，但是中医有奇效。有些病可能中医不行，但是西医很给力。你要选择适合自己的。 第十六点，衣服没必要脱得那么快，毕竟你的长腿很漂亮，但是我希望你的身体更健康。 第十七点，衣服要穿的早，哪一天会突然变冷，你不知道。 第十八点，你的身体对某种食物很抗拒，那么一定不要吃，否则会难受好几天。 第十九点，按时吃饭。 第二十点，多喝水，尿酸高的食物尽量少吃，尤其是海鲜。多喝水可以降低你的尿酸值。建议每天2升水。 第二十一点，要维持身体bmi指数尽量正常，体重除以身高的平方。公斤除以米的平方。尽量在18到25之间。 第二十二点，减肥不要太快心太着急，如果减的太快血管失去脂肪组织支撑。血压容易不稳定。 第二十三点，愿大家都能够身体健康。","categories":[{"name":"随记","slug":"随记","permalink":"http://huangshi.im/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"http://huangshi.im/tags/%E9%9A%8F%E8%AE%B0/"}],"author":"H·stone"},{"title":"python操作excel 文档","slug":"excel","date":"2021-04-13T10:25:30.000Z","updated":"2021-04-13T10:26:48.260Z","comments":true,"path":"2021/04/13/excel/","link":"","permalink":"http://huangshi.im/2021/04/13/excel/","excerpt":"","text":"python操作excel 文档1pip install xlrd&#x3D;&#x3D;1.2.0 1.2才兼容xls 操作 读取excel1234567import xlrddata_path &#x3D; r&quot;C:\\Users\\Administrator\\Desktop\\case.xlsx&quot;content &#x3D; xlrd.open_workbook(data_path)print(content)&gt;&gt;&gt;&lt;xlrd.book.Book object at 0x0000027383095D88&gt; 读取第一个表 读取表名 读取列 读取行12345678910111213141516171819202122content1 &#x3D; content.sheet_by_index(0)print(content1)print(content1.name)print(content1.col_values(0))print(content1.col_values(1))print(content1.col_values(2))print(content1.col_values(3))print(content1.row_values(0))print(content1.row_values(1))print(content1.row_values(2))print(content1.row_values(3))&gt;&gt;&gt;Sheet1[&#39;id&#39;, 1.0, 2.0][&#39;name&#39;, &#39;test empty shoopping cart&#39;, &#39;test normal shopping cart&#39;][&#39;method&#39;, &#39;post&#39;, &#39;post&#39;][&#39;interface&#39;, &#39;api&#x2F;xxx&#39;, &#39;api&#x2F;xxx&#39;][&#39;id&#39;, &#39;name&#39;, &#39;method&#39;, &#39;interface&#39;, &#39;params&#39;, &#39;response&#39;, &#39;except&#39;][1.0, &#39;test empty shoopping cart&#39;, &#39;post&#39;, &#39;api&#x2F;xxx&#39;, &#39;&#123;&quot;user&quot;: &quot;15968484095&quot;, &quot;password&quot;: &quot;f379eaf3c831b04de153469d1bec345e&quot;&#125;&#39;, &#39;&#123;&quot;success&quot;:true,&quot;errorCode&quot;:null,&quot;errorMsg&quot;:null,&quot;sysTime&quot;:1618297162442,&quot;data&quot;:6&#125;&#39;, &#39;&#123;&quot;success&quot;:true&#125;&#39;][2.0, &#39;test normal shopping cart&#39;, &#39;post&#39;, &#39;api&#x2F;xxx&#39;, &#39;&#123;&quot;user&quot;: &quot;15968484095&quot;, &quot;password&quot;: &quot;f379eaf3c831b04de153469d1bec345e&quot;&#125;&#39;, &#39;&#123;&quot;success&quot;:true,&quot;errorCode&quot;:null,&quot;errorMsg&quot;:null,&quot;sysTime&quot;:1618297162442,&quot;data&quot;:6&#125;&#39;, &#39;&#123;&quot;success&quot;:true&#125;&#39;]","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"excel","slug":"excel","permalink":"http://huangshi.im/tags/excel/"}],"author":"H·stone"},{"title":"韭菜的自我修养","slug":"stock","date":"2021-01-26T06:43:12.000Z","updated":"2021-05-31T06:17:24.621Z","comments":true,"path":"2021/01/26/stock/","link":"","permalink":"http://huangshi.im/2021/01/26/stock/","excerpt":"","text":"你所赚的每一分钱都是你对这个世界认知的变现，你所亏的每一分钱都是因为对这个世界认知有缺陷 这个世界最大的公平在于，当一个人的财富大于自己认知的时候，这个社会有100种方法收割你，直到你的认知和财富相匹配为止","categories":[{"name":"韭菜日记","slug":"韭菜日记","permalink":"http://huangshi.im/categories/%E9%9F%AD%E8%8F%9C%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"stock","slug":"stock","permalink":"http://huangshi.im/tags/stock/"}],"author":"H·stone"},{"title":"python+pytest 构建接口自动化项目","slug":"pytest","date":"2021-01-25T13:03:55.000Z","updated":"2021-02-26T04:32:11.610Z","comments":true,"path":"2021/01/25/pytest/","link":"","permalink":"http://huangshi.im/2021/01/25/pytest/","excerpt":"","text":"python+pytest 构建接口自动化项目技术要求：python基础 存在的不足 获取函数名方法不好 token鉴权是否是这种方式？ 未完成一个好用的接口关联机制 无法测试rpc接口 项目构成：autoAPItest allure_results ：测试结果文件夹，通过allure生成，由大量json，txt格式文件组成 commom ：公共方法文件，内部包含，对json的处理，对token的处理，和一些工具类型方法 config：配置文件夹，内部放置了初始的配置和json相关配置的方法 log：存放log日志文件 data：测试用例文件夹（命名已被设定好具体规则） tests：测试断言文件夹|（py文件命名，函数命名已设定） conftest.py：文件存放了fixture，完成对测试用例 的前置后置操作 pytest.ini：pytest的配置文件 run.py: 程序执行函数入口（可以添加用例完成前后的一些操作） 本项目如何完成对接口的自动化测试？访问接口，获取接口的返回值，并获取预先确认的数据，进行对比。判断返回值是否正确。 我的想法， 首先设置了一个存放token的配置文件cookie.json（被测试项目是通过token鉴权），每次项目执行前先完成对cookie.json的清理，然后通过登录被测系统拿到token，写入cookie.json文件 接口文件写成 test-项目-端-接口名.json格式 测试函数通过一样的文件名去读取对应的数据，通过工具文件中的公共方法读取接口文件后返回成请求数据，随后断言结果是否正确。 上代码：commom handel_cookie.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&quot;&quot;&quot;获取cookie写入cookie提供调用&quot;&quot;&quot;import jsonimport osimport requestsfrom commom.handel_json import get_jsondatafrom commom.unit import get_init_datafrom commom.log import MyLogbase_path &#x3D; os.path.dirname(os.path.dirname(__file__))def get_token_init(): &quot;&quot;&quot; 【登录账号获取token】 账号密码登录获取cookie :return: &quot;&quot;&quot; unit_data &#x3D; get_jsondata(&#39;config.json&#39;) headers &#x3D; get_jsondata(&quot;headers.json&quot;)[&#39;header&#39;] token_dict &#x3D; &#123;&#125; for (key, value) in unit_data[&#39;test&#39;].items(): data &#x3D; get_init_data(key) if data is not None: r &#x3D; requests.post(value + unit_data[&quot;login_path&quot;][&quot;path&quot;], headers&#x3D;headers, data&#x3D;json.dumps(data)) res &#x3D; json.loads(r.text) if res[&#39;errorMsg&#39;] &#x3D;&#x3D; &#39;手机号或邮箱未注册&#39;: MyLog.error(&quot;手机号或邮箱未注册,无法登录&quot;) return None else: token &#x3D; res[&#39;data&#39;][&#39;token&#39;] token_dict[key] &#x3D; token MyLog.info(&quot;成功获取token&quot;) return token_dictdef handel_token(): &quot;&quot;&quot; 1.获取token 2.读取json 3.修改json 4.回写json :return: &quot;&quot;&quot; token_dict &#x3D; get_token_init() for (key, value) in token_dict.items(): key &#x3D; key[0:6] headers &#x3D; &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: f&quot;&#123;value&#125;&quot; &#125; old_headers &#x3D; get_jsondata(&#39;headers.json&#39;) old_headers[key][&#39;headers&#39;] &#x3D; headers with open(base_path + r&quot;\\config\\headers.json&quot;, &quot;w&quot;) as f: f.write(json.dumps(old_headers)) MyLog.info(&quot;成功写入headers内容进入headers文件&quot;)def clear(): &quot;&quot;&quot; 清理cookie :return: &quot;&quot;&quot; token_dict &#x3D; get_token_init() for (key, value) in token_dict.items(): key &#x3D; key[0:6] headers &#x3D; &#123;&#125; old_headers &#x3D; get_jsondata(&#39;headers.json&#39;) old_headers[key][&#39;headers&#39;] &#x3D; headers with open(base_path + r&quot;\\config\\headers.json&quot;, &quot;w&quot;) as f: f.write(json.dumps(old_headers)) MyLog.info(&quot;完成对json配置文件的清理&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: handel_token() handel_json.py 1234567891011121314151617import jsonimport osdef get_jsondata(file_name): &quot;&quot;&quot; 【获取json数据，判断是什么类型的json文件,并且返回获取的数据】 :param file_name: 文件名 :return: &quot;&quot;&quot; if file_name.find(&quot;_&quot;) &gt;&#x3D; 0: file_name &#x3D; os.path.dirname(os.path.dirname(__file__)) + r&quot;\\data\\\\&quot; + file_name else: file_name &#x3D; os.path.dirname(os.path.dirname(__file__)) + r&quot;\\config\\\\&quot; + file_name with open(file_name, encoding&#x3D;&#39;UTF-8&#39;) as f: data &#x3D; json.load(f) return data log.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&quot;&quot;&quot;实现log日志的公共方法调用规则 例：from commom.Log import *self.logger.warning(f&quot;当前json文件路径获取出错：&#123;file_path&#125;&quot;)&quot;&quot;&quot;import osimport timeimport logging.handlers# 日志打印等级LEVELS &#x3D; &#123; &#39;debug&#39;: logging.DEBUG, &#39;info&#39;: logging.INFO, &#39;warning&#39;: logging.WARNING, &#39;error&#39;: logging.ERROR, &#39;critical&#39;: logging.CRITICAL&#125;# 创建一个日志logger &#x3D; logging.getLogger()level &#x3D; &#39;default&#39;# 创建日志文件方法def create_file(filename): path &#x3D; filename[0:filename.rfind(&#39;&#x2F;&#39;)] if not os.path.isdir(path): os.makedirs(path) if not os.path.isfile(filename): fd &#x3D; open(filename, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) fd.close() else: pass# 给logger添加handler 添加内容到日志句柄中def set_handler(levels): if levels &#x3D;&#x3D; &#39;error&#39;: logger.addHandler(MyLog.err_handler) logger.addHandler(MyLog.handler)# 在记录日志之后移除句柄def remove_handler(levels): if levels &#x3D;&#x3D; &#39;error&#39;: logger.removeHandler(MyLog.err_handler) logger.removeHandler(MyLog.handler)def get_current_time(): return time.strftime(MyLog.date, time.localtime(time.time()))class MyLog: path &#x3D; os.path.dirname(os.path.dirname(os.path.abspath(__file__))) log_file &#x3D; path + &#39;&#x2F;Log&#x2F;log.log&#39; err_file &#x3D; path + &#39;&#x2F;Log&#x2F;err.log&#39; logger.setLevel(LEVELS.get(level, logging.NOTSET)) create_file(log_file) create_file(err_file) date &#x3D; &#39;%Y-%m-%d %H:%M:%S&#39; # 创建一个handler，用于写入日志文件 handler &#x3D; logging.FileHandler(log_file, encoding&#x3D;&#39;utf-8&#39;) err_handler &#x3D; logging.FileHandler(err_file, encoding&#x3D;&#39;utf-8&#39;) @staticmethod def debug(log_meg): set_handler(&#39;debug&#39;) # 文件中输出模式 logger.debug(log_meg) remove_handler(&#39;debug&#39;) @staticmethod def info(log_meg): set_handler(&#39;info&#39;) logger.info(log_meg) remove_handler(&#39;info&#39;) @staticmethod def warning(log_meg): set_handler(&#39;warning&#39;) logger.warning(log_meg) remove_handler(&#39;warning&#39;) @staticmethod def error(log_meg): set_handler(&#39;error&#39;) logger.error(log_meg) remove_handler(&#39;error&#39;) @staticmethod def critical(log_meg): set_handler(&#39;critical&#39;) logger.error(log_meg) remove_handler(&#39;critical&#39;) # 设置控制台输出格式 formatter &#x3D; logging.Formatter(&quot;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&quot;) # 再创建一个handler，用于输出到控制台 console &#x3D; logging.StreamHandler() console.setFormatter(formatter) handler.setFormatter(formatter) err_handler.setFormatter(formatter) logger.addHandler(console) console.setLevel(logging.INFO)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: MyLog.debug(&quot;This is debug message&quot;) MyLog.info(&quot;This is info message&quot;) MyLog.warning(&quot;This is warning message&quot;) MyLog.error(&quot;This is error&quot;) MyLog.critical(&quot;This is critical message&quot;) unit.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from commom.handel_json import get_jsondatafrom commom.log import MyLogdef get_host(file_name): if file_name.find(&quot;ubq&quot;) &gt;&#x3D; 0: if file_name.find(&quot;_fe_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;ubq_fe_host&quot;] return host elif file_name.find(&quot;_be_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;ubq_be_host&quot;] return host else: # 此处应打印log日志记录无法在文件名中找到对应标志，文件名拼写错误 MyLog.debug(&quot;无法在文件名中找到端标识&quot;) return None elif file_name.find(&quot;mlm&quot;) &gt;&#x3D; 0: if file_name.find(&quot;_fe_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;mlm_fe_host&quot;] return host elif file_name.find(&quot;_be_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;mlm_be_host&quot;] return host else: MyLog.debug(&quot;无法在文件名中找到端标识&quot;) # 此处应打印log日志记录无法在文件名中找到对应标志，文件名拼写错误 return None elif file_name.find(&quot;gzb&quot;) &gt;&#x3D; 0: if file_name.find(&quot;_fe_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;gzb_fe_host&quot;] return host elif file_name.find(&quot;_be_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;gzb_be_host&quot;] return host elif file_name.find(&quot;_sh_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;gzb_sh_host&quot;] return host else: MyLog.debug(&quot;无法在文件名中找到端标识&quot;) # 此处应打印log日志记录无法在文件名中找到对应标志，文件名拼写错误 return None else: # 此处应打印log日志记录无法在文件名中找到对应标志 MyLog.info(&quot;无法在文件名中找到系统标识，文件名错误&quot;) return Nonedef get_init_data(key): key &#x3D; key + &quot;_data&quot; data &#x3D; get_jsondata(&quot;config.json&quot;)[key] if data &#x3D;&#x3D; &#123;&#125;: MyLog.info(f&quot;无法获取到&#123;key&#125;对应的初始化账号数据&quot;) return None return datadef get_data(name): json_name &#x3D; name + &#39;.json&#39; json_data &#x3D; get_jsondata(json_name) mid_name &#x3D; name[5:11] headers &#x3D; get_jsondata(&#39;headers.json&#39;)[mid_name][&quot;headers&quot;] host &#x3D; get_host(json_name) url &#x3D; host + json_data[&#39;url&#39;] par &#x3D; json_data[&#39;testcase&#39;][0] return url, headers, par config config.json(数据相关已脱敏(◔‸◔）) 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;test&quot;: &#123; &quot;ubq_fe_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot;, &quot;ubq_be_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot;, &quot;ubq_sh_host&quot;: &quot;http:&#x2F;&#x2F;xxx&quot;, &quot;mlm_fe_host&quot;: &quot;http:&#x2F;&#x2F;xxx&quot;, &quot;mlm_be_host&quot;: &quot;http:&#x2F;&#x2F;xxx&quot;, &quot;gzb_be_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot;, &quot;gzb_sh_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot; &#125;, &quot;ubq_fe_host_data&quot;:&#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;ubq_be_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;ubq_sh_host_data&quot;: &#123; &#125;, &quot;mlm_fe_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;mlm_be_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;gzb_be_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxxx&quot;, &quot;password&quot;:&quot;xxxxx&quot; &#125;, &quot;gzb_sh_host_data&quot;: &#123; &#125;, &quot;login_path&quot;: &#123; &quot;path&quot;: &quot;&#x2F;xxxxx&#x2F;xxxx&quot; &#125;&#125; header.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; &quot;header&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot; &#125;, &quot;ubq_fe&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;ubq_be&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;ubq_sh&quot;: &#123; &quot;headers&quot;: &#123;&#125; &#125;, &quot;mlm_fe&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;mlm_be&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;gzb_fe&quot;: &#123; &quot;headers&quot;: &#123;&#125; &#125;, &quot;gzb_be&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;gzb_sh&quot;: &#123; &quot;headers&quot;: &#123;&#125; &#125;&#125; data中的用例 12345678910111213141516171819&#123; &quot;name&quot;:&quot;项目名&quot;, &quot;url&quot;:&quot;&#x2F;xxxx&#x2F;xxxxx&#x2F;xxxx&#x2F;xxxx&quot;, &quot;method&quot;:&quot;GET&quot;, &quot;testcase&quot;:[ &#123; &quot;name&quot;:&quot;用例名&quot;, &quot;params&quot;:&#123; &quot;demoid&quot;:&quot;xxxxxxxxxxxxxxxx&quot; &#125;, &quot;validate&quot;: &#123; &quot;success&quot;:&quot;True&quot;, &quot;data&quot;: &#123; &quot;xxxxx&quot;: &quot;xxxxx&quot; &#125; &#125; &#125; ]&#125; test:通过函数名来确定对应的用例 1234567891011121314from commom.unit import get_dataimport requestsimport sysimport allureclass Test(object): @allure.feature(&#39;验证漫联盟管理系统存证详情&#39;) def test_mlm_be_evidenceDetail(self): url, headers, par &#x3D; get_data(sys._getframe().f_code.co_name) r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, params&#x3D;par[&#39;params&#39;]) response &#x3D; r.json() assert r.status_code &#x3D;&#x3D; 200 assert str(response[&quot;success&quot;]) &#x3D;&#x3D; par[&#39;validate&#39;][&#39;success&#39;] conftst.py pytest的fixtue功能，可对接口验证进行前后置操作 1234567891011121314151617181920import pytestfrom commom.unit import get_dataimport requestsimport json@pytest.fixture(scope&#x3D;&quot;class&quot;)def del_car(): &quot;&quot;&quot; 后置删除购物车添加 :return: &quot;&quot;&quot; yield url, headers, par &#x3D; get_data(&quot;test_mlm_fe_list&quot;) r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, params&#x3D;par[&#39;params&#39;]) response &#x3D; r.json() ids &#x3D; response[&#39;data&#39;][0][&#39;shoppingCartProductVOS&#39;][0][&#39;id&#39;] data &#x3D; &#123;&quot;ids&quot;:[int(ids)]&#125; url, headers, par &#x3D; get_data(&quot;test_mlm_fe_delete&quot;) res &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;json.dumps(data)) return del_car pytest.ini pytest的配置控制台不显示乱码 12[pytest]disable_test_id_escaping_and_forfeit_all_rights_to_community_support &#x3D; True run.py 123456789101112131415&quot;&quot;&quot;主程序入口&quot;&quot;&quot;import pytestfrom commom.handel_cookie import handel_token, clearif __name__ &#x3D;&#x3D; &#39;__main__&#39;: &quot;&quot;&quot; 1.清理配置信息 1.获取token，存储到cookie.json中供全局使用 &quot;&quot;&quot; clear() handel_token() pytest.main([&#39;-s&#39;, &#39;-q&#39;, &#39;--alluredir&#x3D;allure_results&#39;])","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://huangshi.im/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"pytest","slug":"pytest","permalink":"http://huangshi.im/tags/pytest/"}],"author":"H·stone"},{"title":"allure测试报告在项目中的使用实践","slug":"report","date":"2021-01-22T10:11:56.000Z","updated":"2021-01-22T08:36:35.243Z","comments":true,"path":"2021/01/22/report/","link":"","permalink":"http://huangshi.im/2021/01/22/report/","excerpt":"","text":"allure测试报告在自动化项目中的使用Allure Framework是一种灵活的轻量级多语言测试报告工具，美观且功能丰富 使用allure报告的前置条件 下载安装jdk，并配置好环境变量 下载allure安装包解压到文件夹（任意即可），并配置环境变量 pip install allure-pytest 使用： 运行项目时执行，指定生成的allure文件存放的文件夹 123456789if __name__ &#x3D;&#x3D; &#39;__main__&#39;: &quot;&quot;&quot; 1.清理配置信息 1.获取token，存储到cookie.json中供全局使用 &quot;&quot;&quot; clear() handel_token() pytest.main([&#39;-s&#39;, &#39;-q&#39;, &#39;--alluredir&#x3D;allure_results&#39;]) allure_results文件夹中生成了一堆json，txt等格式的莫名文件 1allure serve allure_results执行后会调起浏览器展示测试报告 此处需注意，只能使用火狐浏览器 1234567(venv) C:\\Users\\Administrator\\Desktop\\autotestAPI&gt;allure serve allure_resultsGenerating report to temp directory...Report successfully generated to C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\2357441130466454662\\allure-reportStarting web server...2021-01-22 15:42:06.658:INFO::main: Logging initialized @2962ms to org.eclipse.jetty.util.log.StdErrLogServer started at &lt;http:&#x2F;&#x2F;192.168.0.101:5948&#x2F;&gt;. Press &lt;Ctrl+C&gt; to exit","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"allure","slug":"allure","permalink":"http://huangshi.im/tags/allure/"}],"author":"H·stone"},{"title":"盐","slug":"hee","date":"2021-01-18T11:11:30.000Z","updated":"2021-04-12T07:12:30.277Z","comments":true,"path":"2021/01/18/hee/","link":"","permalink":"http://huangshi.im/2021/01/18/hee/","excerpt":"","text":"遇上了一个账号需要改动密码，直接在数据库中改动了，发现无法登录，询问后端才知道，密码并不是简单的，直接sha256哈希userid出来的，经过了三重updata的拼接。python复现↓ 12345678910import hashlibuserID &#x3D; &#39;788802624700001609839882&#39;passWord &#x3D; &#39;f379eaf3c831b04de153469d1bec345e&#39;sha &#x3D; hashlib.sha256()sha.update(userID.encode(&#39;UTF-8&#39;))sha.update(passWord.encode(&#39;UTF-8&#39;))sha.update(userID.encode(&#39;UTF-8&#39;))print(sha.hexdigest()) 但是这个还有bug，哈希过程中并未加盐，hacker可以通过彩虹表反推，得到密码。 注册功能一般在数据库中存放的密码都是经过加密 简单的加密就是直接 sha256等等 ，但是如果通过彩虹表反推，是有可能被破解的。 所以一般会在生成 hash码的时候 加盐。 盐：出于预先防止黑客利用彩虹表反推盗用用户的密码账户信息，就需要给密码加‘盐’，其实简单来说，就是在hashlib模块中的md5加密方法时，传入一个你自己想给的盐，或者干脆随机生成（比较安全，将盐封装在类中） 彩虹表：彩虹表是一个用于加密散列函数逆运算的预先计算好的表, 为破解密码的散列值（或称哈希值、微缩图、摘要、指纹、哈希密文）而准备。一般主流的彩虹表都在100G以上。 这样的表常常用于恢复由有限集字符组成的固定长度的纯文本密码 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839import hashlib,random#注册storage&#x3D;&#123;&#125;def registration(u,p): if u in storage: return &#39;username occupied.please choose another username...&#39; else: storage[u]&#x3D;Users(u,p)#加密方法def get_md5(s): return hashlib.md5(s.encode(&#39;utf-8&#39;)).hexdigest()#登陆class Users(object): def __init__(self,username,password): self.username&#x3D;username #!!!!!!!注意盐是随机给的，每注册一个账号给一次盐，封装在Users类里面，在login函数里比较相等时， # a.salt是注册时封装好的盐，这时是固定的盐，所以只要账号密码对了就可以了。 self.salt&#x3D;&#39;&#39;.join([chr(random.randint(48,122)) for i in range(20)]) self.password&#x3D;get_md5(password+self.salt)def login(user,pw): if user not in storage.keys(): return &#39;wrong username&#39; else: a&#x3D;storage[user] if a.password&#x3D;&#x3D;get_md5(pw+a.salt): return &#39;succeeded&#39; else: return &#39;wrong password&#39;registration(&#39;mary&#39;,&#39;12345&#39;)registration(&#39;bob&#39;,&#39;aa895&#39;)registration(&#39;kirk&#39;,&#39;ba155&#39;)print(storage)print(login(&#39;mary&#39;,&#39;12345&#39;))","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"sha256","slug":"sha256","permalink":"http://huangshi.im/tags/sha256/"}],"author":"H·stone"},{"title":"尝试Monkey测试","slug":"Monkeytest","date":"2020-09-17T01:56:26.000Z","updated":"2021-01-25T08:08:32.599Z","comments":true,"path":"2020/09/17/Monkeytest/","link":"","permalink":"http://huangshi.im/2020/09/17/Monkeytest/","excerpt":"","text":"因为业务的关系一直聚焦于功能测试，接口测试，还没有尝试过跑Monkey脚本，试了一试。 参考： https://ww.cnblogs.com/lauren1003/p/6193277.html https://www.cnblogs.com/tekoyo/p/5288661.html 实践：monkey测试 首要条件：安装JDK 安装SDK 连接模拟器 –连接模拟器 mumu模拟器 1adb connect 127.0.0.1:7555 –查询应用程序 1adb shell dumpsys activity|find &quot;mFocusedActivity&quot; –点击1000下 1adb shell monkey -p com.thgy.uprotect 1000 –点击并生成日志 1adb shell monkey -p com.thgy.uprotect -s 500 --ignore-crashes --ignore-timeouts --monitor-native-crashes -v -v -v 10000 &gt; D:\\monkey.txt","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Monkey","slug":"Monkey","permalink":"http://huangshi.im/tags/Monkey/"}],"author":"H·stone"},{"title":"弱网测试","slug":"weaknet","date":"2019-04-16T10:11:56.000Z","updated":"2021-01-21T05:51:00.695Z","comments":true,"path":"2019/04/16/weaknet/","link":"","permalink":"http://huangshi.im/2019/04/16/weaknet/","excerpt":"","text":"ios弱网配置操作步骤： 进入开发者选项 选择NETWORK LINK CONDITIONER 将ENABLE打开 选择对应的网络环境，100%Loss、3G、Very Bad Network、WiFi等 自定义网络环境：Add a profile 备注：bandwidth是带宽，以k/s为单位；packet loss是丢包率，按百分比计算；delay延时，单位是毫秒，1000毫秒等于1秒。下面是我配的几个参考网络环境。 有的可以采用无线热点进行限速 charles如何设置弱网","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"弱网测试","slug":"弱网测试","permalink":"http://huangshi.im/tags/%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/"}],"author":"H·stone"},{"title":"selenium中曾经遇上问题的地方","slug":"selenium","date":"2019-01-29T06:43:12.000Z","updated":"2021-01-25T10:14:36.378Z","comments":true,"path":"2019/01/29/selenium/","link":"","permalink":"http://huangshi.im/2019/01/29/selenium/","excerpt":"","text":"关于元素互相遮挡元素块互有遮挡 会造成 click（）某个元素的时候，点击不到想要的元素 点击到别的地方去。 123sub_loc &#x3D; &#39;&#x2F;html&#x2F;body&#x2F;div[2]&#39;sub &#x3D; bp.By_xpath(sub_loc)driver.execute_script(&#39;$(arguments[0]).fadeOut()&#39;, sub) 直接找到遮盖了目标元素的元素块，直接隐藏。 显示/隐式等待隐式等待当查找元素没有立即出现的时候，隐式等待等待一段时间后再查找DOM，默认时间是0 123456from selenium import webdriverbrowser &#x3D; webdriver.Chrome()browser.implicitly_wait(10)browser.get(&quot;http:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&quot;)input &#x3D; browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input) 显式等待指定一个等待条件，设置一个最长等待时间等带时间内满足了条件就正常返回 1234567891011121314from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser &#x3D; webdriver.Chrome()browser.get(&quot;http:&#x2F;&#x2F;www.taobao.com&#x2F;&quot;)wait &#x3D; WebDriverWait(browser,10)input &#x3D; wait.until(EC.presence_of _element_located((By.ID,&#39;q&#39;)))button &#x3D; wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR,&#39;.btn-search&#39;)))print(input,button)​ def ByXpath_wait_time(self, loc_arg): &quot;&quot;&quot;元素获取方式之xpath-显示等待&quot;&quot;&quot; return WebDriverWait(self.driver, 15, 3).until(EC.presence_of_element_located((By.XPATH, loc_arg))) 执行javascript123456from selenium import webdriver​browser &#x3D; webdriver.Chrome()browser.get(&quot;http:&#x2F;&#x2F;www.taobao.com&#x2F;&quot;)browser.execute_script(&#39;window.scrollTo(0,document.body.scrollHeight)&#39;)browser.execute_script(&#39;alert(&quot;To Bottom&quot;)&#39;) #实现了页面从上到下拉​ chrome无头模式123chrome_options &#x3D; Options() chrome_options.add_argument(&#39;--headless&#39;) driver &#x3D; webdriver.Chrome(chrome_options&#x3D;chrome_options) selenium对于alert的处理（坑）1234567try: WebDriverWait(driver, 5).until(EC.alert_is_present(), &#39;Timed out waiting for alerts to appear&#39;) alert &#x3D; driver.switch_to.alert alert.accept() print(&quot;alert accepted&quot;) except TimeoutException: print(&quot;no alert&quot;) ==不是所有alert警告都是弹窗后瞬间警告，需要加上等待==","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://huangshi.im/tags/selenium/"},{"name":"ui自动化","slug":"ui自动化","permalink":"http://huangshi.im/tags/ui%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"author":"H·stone"},{"title":"总结工作中一般会用到的git操作","slug":"git","date":"2018-10-15T15:24:15.000Z","updated":"2021-09-02T02:41:49.574Z","comments":true,"path":"2018/10/15/git/","link":"","permalink":"http://huangshi.im/2018/10/15/git/","excerpt":"","text":"工作中git常用 释义 代码 备注 查看当前 git branch 查看远程 git branch -a 本地修改撤销 git checkout . 切换分支 git checkout 分支名 查看当前分支和远程分支的关联 git branch -vv 删除分支 git branch -D 分支名 切换并创建scm 关联到远程的scm git checkout -b scm origin/scm scm是分支名 他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add . 暂存区提交版本库 git commit -m “备注” 远端更新下拉 git pull 相当于是从远程获取最新版本并merge到本地 本地推送远端 git pushgit push origin scm 如果已经关联上了，可以push但是 最好还是 指定远程分支 以免推送到master master合并到本地 （本地）：git merge master 回退到某个版本 git reset –hard f10a9 查看版本信息 git log –pretty=oneline 查看历史 git reflog 查看版本当前版本号 git cherry origin/scm_new 查看一共有多少版本号 git cherry origin scm_new 123456当你想更正别人仓库里的错误时，要走一个流程：先 fork 别人的仓库，相当于拷贝一份，相信我，不会有人直接让你改修原仓库的clone 到本地分支，做一些 bug fix发起 pull request 给原仓库，让他看到你修改的 bug原仓库 review 这个 bug，如果是正确的话，就会 merge 到他自己的项目中至此，整个 pull request 的过程就结束了。 本地开发后合并到master上比如 本地dev开发完 123git add .git commit -m &#39;改动了哪里&#39;git push origin master 推送到远程，尽量指定远程分支 然后dev合并到 master，要先切换到master 12git checkout master 切换master 当然这个是本地的master分支git pull origin master 从远端拉下最新的master代码，毕竟别人也可能修改了master 然后在master分支 合并 dev代码 1git merge dev 合并dev代码 然后查看状态 123456git statusOn branch masterYour branch is ahead of &#39;origin&#x2F;master&#39; by 12 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 上面的意思就是你有12个commit，需要push到远程master上执行下面命令即可 1git push origin master 应用储藏的场景123git stash git pullgit stash pop 应用分支重命名的场景比如：想把本地和远程的某个分支 更改名字1234567891011重命名远程分支对应的本地分支git branch -m scm scm_old删除远程分支git push --delete origin scm上传新命名的本地git push origin scm_old把修改后的本地分支与远程分支关联git branch --set-upstream-to origin&#x2F;scm_ol","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://huangshi.im/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"git","slug":"git","permalink":"http://huangshi.im/tags/git/"}],"author":"H·stone"},{"title":"DNS详细解析过程","slug":"dns","date":"2018-05-20T11:28:15.000Z","updated":"2021-05-28T05:02:31.115Z","comments":true,"path":"2018/05/20/dns/","link":"","permalink":"http://huangshi.im/2018/05/20/dns/","excerpt":"","text":"浏览器是会解析www.baidu.com这个地址，先查找自己的DNS缓存，查看是否有缓存中有对应的额条目，如果有且没有过期，那么解析结束。 1chrome查看自己的DNS缓存chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 2、如果浏览器缓存中没有，会到操作系统自身中缓存中查找，如果有且没有过期，那么解析结束。 1windows下ipconfig&#x2F;displaydns 来进行查看 3、如果自身中缓存也没有，那么尝试读取hosts文件，看看这里面有没有该域名对应的IP地址，如果有则解析成功。 1hosts文件：（位于C:\\Windows\\System32\\drivers\\etc） 4、如果在hosts文件中也没有，则chrmo浏览器发起了一个DNS的系统调用，就会首选向本地配置的DNS服务器（运营商提供）发起域名解析的请求，本地配置的DNS 服务器在接收请求后，首先查找自己的缓存。找到对应的条目，有且没有过期，则解析成功。 5、如果本地配置的DNS服务器（运营商提供）中也没有，DNS服务器（运营商提供）会代我们的浏览器发起迭代DNS解析请求，首先是找到根域的DNS服务器IP（一共13台，已经内置在运营商的DNS服务器中了），向根域服务器发起请求询问www.baidu.com的IP地址是多少？。 6、根域发现这个www.baidu.com是顶级域com域的域名，会回复运营商的DNS服务器无法知道 www.baidu.com的IP地址，但是可以知道com域的IP地址，于是运营商的DNS服务器又向com域的IP地址发送请求，询问www.baidu.com的IP地址是多少？。 7、com域的服务器会回复运营商的DNS服务器，无法得知www.baidu.com的IP地址，但是知道baidu.com这个域的DNS地址，你去请求它。 8、运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求询问www.baidu.com的IP地址是多少？，这个时候baidu.com域的DNS服务器查询自己，发现baidu.com的IP地址后，返回给运营商的DNS服务器，运营商的DNS服务器拿到后返回给浏览器。","categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://huangshi.im/tags/%E7%BD%91%E7%BB%9C/"},{"name":"http","slug":"http","permalink":"http://huangshi.im/tags/http/"}],"author":"H·stone"}],"categories":[{"name":"工作","slug":"工作","permalink":"http://huangshi.im/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"随记","slug":"随记","permalink":"http://huangshi.im/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"韭菜日记","slug":"韭菜日记","permalink":"http://huangshi.im/categories/%E9%9F%AD%E8%8F%9C%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://huangshi.im/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://huangshi.im/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"工具函数","slug":"工具函数","permalink":"http://huangshi.im/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"},{"name":"工具相关","slug":"工具相关","permalink":"http://huangshi.im/tags/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"},{"name":"随记","slug":"随记","permalink":"http://huangshi.im/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"excel","slug":"excel","permalink":"http://huangshi.im/tags/excel/"},{"name":"stock","slug":"stock","permalink":"http://huangshi.im/tags/stock/"},{"name":"pytest","slug":"pytest","permalink":"http://huangshi.im/tags/pytest/"},{"name":"allure","slug":"allure","permalink":"http://huangshi.im/tags/allure/"},{"name":"sha256","slug":"sha256","permalink":"http://huangshi.im/tags/sha256/"},{"name":"Monkey","slug":"Monkey","permalink":"http://huangshi.im/tags/Monkey/"},{"name":"弱网测试","slug":"弱网测试","permalink":"http://huangshi.im/tags/%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/"},{"name":"selenium","slug":"selenium","permalink":"http://huangshi.im/tags/selenium/"},{"name":"ui自动化","slug":"ui自动化","permalink":"http://huangshi.im/tags/ui%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"git","slug":"git","permalink":"http://huangshi.im/tags/git/"},{"name":"网络","slug":"网络","permalink":"http://huangshi.im/tags/%E7%BD%91%E7%BB%9C/"},{"name":"http","slug":"http","permalink":"http://huangshi.im/tags/http/"}]}