{"meta":{"title":"H·stone","subtitle":"hahaha","description":"blog","author":"H·stone","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-02-26T04:40:42.338Z","updated":"2021-02-26T04:40:42.338Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人简介一个普通不过的大龄单身男青年相信尘埃里会开出一朵花"}],"posts":[{"title":"韭菜的自我修养","slug":"stock","date":"2021-01-26T06:43:12.000Z","updated":"2021-04-12T03:26:13.809Z","comments":true,"path":"2021/01/26/stock/","link":"","permalink":"http://example.com/2021/01/26/stock/","excerpt":"","text":"你所赚的每一分钱都是你对这个世界认知的变现，你所亏的每一分钱都是因为对这个世界认知有缺陷 这个世界最大的公平在于，当一个人的财富大于自己认知的时候，这个社会有100种方法收割你，直到你的认知和财富相匹配为止 2021/1/25 下跌趋势再牛逼也不碰 2021/1/26 有赚就走，立马换地方 2021/1/26 还是找箭头和回踩，符合就跟 不符合马上切 2021/1/26 管住手，给自己制定一套必须执行（亏损也必须执行）的操作策略 2021/1/28 只做一波，上冲后横盘直接走，直冲向上的回落不要赌踩线 2021/2/03 下跌破位直接走 2021/2/03 上涨趋势的票，加仓就在早盘加仓，即可吃T价，也可以不用高成本买 2021/2/26 上涨加仓会在上涨过程中抬高自己的持仓成本，所以止盈点位应该是10% 2021/3/10 盈利后高位盘整，先行撤出","categories":[{"name":"韭菜日记","slug":"韭菜日记","permalink":"http://example.com/categories/%E9%9F%AD%E8%8F%9C%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"stock","slug":"stock","permalink":"http://example.com/tags/stock/"}],"author":"H·stone"},{"title":"python+pytest 构建接口自动化项目","slug":"pytest","date":"2021-01-25T13:03:55.000Z","updated":"2021-02-26T04:32:11.610Z","comments":true,"path":"2021/01/25/pytest/","link":"","permalink":"http://example.com/2021/01/25/pytest/","excerpt":"","text":"python+pytest 构建接口自动化项目技术要求：python基础 存在的不足 获取函数名方法不好 token鉴权是否是这种方式？ 未完成一个好用的接口关联机制 无法测试rpc接口 项目构成：autoAPItest allure_results ：测试结果文件夹，通过allure生成，由大量json，txt格式文件组成 commom ：公共方法文件，内部包含，对json的处理，对token的处理，和一些工具类型方法 config：配置文件夹，内部放置了初始的配置和json相关配置的方法 log：存放log日志文件 data：测试用例文件夹（命名已被设定好具体规则） tests：测试断言文件夹|（py文件命名，函数命名已设定） conftest.py：文件存放了fixture，完成对测试用例 的前置后置操作 pytest.ini：pytest的配置文件 run.py: 程序执行函数入口（可以添加用例完成前后的一些操作） 本项目如何完成对接口的自动化测试？访问接口，获取接口的返回值，并获取预先确认的数据，进行对比。判断返回值是否正确。 我的想法， 首先设置了一个存放token的配置文件cookie.json（被测试项目是通过token鉴权），每次项目执行前先完成对cookie.json的清理，然后通过登录被测系统拿到token，写入cookie.json文件 接口文件写成 test-项目-端-接口名.json格式 测试函数通过一样的文件名去读取对应的数据，通过工具文件中的公共方法读取接口文件后返回成请求数据，随后断言结果是否正确。 上代码：commom handel_cookie.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&quot;&quot;&quot;获取cookie写入cookie提供调用&quot;&quot;&quot;import jsonimport osimport requestsfrom commom.handel_json import get_jsondatafrom commom.unit import get_init_datafrom commom.log import MyLogbase_path &#x3D; os.path.dirname(os.path.dirname(__file__))def get_token_init(): &quot;&quot;&quot; 【登录账号获取token】 账号密码登录获取cookie :return: &quot;&quot;&quot; unit_data &#x3D; get_jsondata(&#39;config.json&#39;) headers &#x3D; get_jsondata(&quot;headers.json&quot;)[&#39;header&#39;] token_dict &#x3D; &#123;&#125; for (key, value) in unit_data[&#39;test&#39;].items(): data &#x3D; get_init_data(key) if data is not None: r &#x3D; requests.post(value + unit_data[&quot;login_path&quot;][&quot;path&quot;], headers&#x3D;headers, data&#x3D;json.dumps(data)) res &#x3D; json.loads(r.text) if res[&#39;errorMsg&#39;] &#x3D;&#x3D; &#39;手机号或邮箱未注册&#39;: MyLog.error(&quot;手机号或邮箱未注册,无法登录&quot;) return None else: token &#x3D; res[&#39;data&#39;][&#39;token&#39;] token_dict[key] &#x3D; token MyLog.info(&quot;成功获取token&quot;) return token_dictdef handel_token(): &quot;&quot;&quot; 1.获取token 2.读取json 3.修改json 4.回写json :return: &quot;&quot;&quot; token_dict &#x3D; get_token_init() for (key, value) in token_dict.items(): key &#x3D; key[0:6] headers &#x3D; &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: f&quot;&#123;value&#125;&quot; &#125; old_headers &#x3D; get_jsondata(&#39;headers.json&#39;) old_headers[key][&#39;headers&#39;] &#x3D; headers with open(base_path + r&quot;\\config\\headers.json&quot;, &quot;w&quot;) as f: f.write(json.dumps(old_headers)) MyLog.info(&quot;成功写入headers内容进入headers文件&quot;)def clear(): &quot;&quot;&quot; 清理cookie :return: &quot;&quot;&quot; token_dict &#x3D; get_token_init() for (key, value) in token_dict.items(): key &#x3D; key[0:6] headers &#x3D; &#123;&#125; old_headers &#x3D; get_jsondata(&#39;headers.json&#39;) old_headers[key][&#39;headers&#39;] &#x3D; headers with open(base_path + r&quot;\\config\\headers.json&quot;, &quot;w&quot;) as f: f.write(json.dumps(old_headers)) MyLog.info(&quot;完成对json配置文件的清理&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: handel_token() handel_json.py 1234567891011121314151617import jsonimport osdef get_jsondata(file_name): &quot;&quot;&quot; 【获取json数据，判断是什么类型的json文件,并且返回获取的数据】 :param file_name: 文件名 :return: &quot;&quot;&quot; if file_name.find(&quot;_&quot;) &gt;&#x3D; 0: file_name &#x3D; os.path.dirname(os.path.dirname(__file__)) + r&quot;\\data\\\\&quot; + file_name else: file_name &#x3D; os.path.dirname(os.path.dirname(__file__)) + r&quot;\\config\\\\&quot; + file_name with open(file_name, encoding&#x3D;&#39;UTF-8&#39;) as f: data &#x3D; json.load(f) return data log.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&quot;&quot;&quot;实现log日志的公共方法调用规则 例：from commom.Log import *self.logger.warning(f&quot;当前json文件路径获取出错：&#123;file_path&#125;&quot;)&quot;&quot;&quot;import osimport timeimport logging.handlers# 日志打印等级LEVELS &#x3D; &#123; &#39;debug&#39;: logging.DEBUG, &#39;info&#39;: logging.INFO, &#39;warning&#39;: logging.WARNING, &#39;error&#39;: logging.ERROR, &#39;critical&#39;: logging.CRITICAL&#125;# 创建一个日志logger &#x3D; logging.getLogger()level &#x3D; &#39;default&#39;# 创建日志文件方法def create_file(filename): path &#x3D; filename[0:filename.rfind(&#39;&#x2F;&#39;)] if not os.path.isdir(path): os.makedirs(path) if not os.path.isfile(filename): fd &#x3D; open(filename, mode&#x3D;&#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) fd.close() else: pass# 给logger添加handler 添加内容到日志句柄中def set_handler(levels): if levels &#x3D;&#x3D; &#39;error&#39;: logger.addHandler(MyLog.err_handler) logger.addHandler(MyLog.handler)# 在记录日志之后移除句柄def remove_handler(levels): if levels &#x3D;&#x3D; &#39;error&#39;: logger.removeHandler(MyLog.err_handler) logger.removeHandler(MyLog.handler)def get_current_time(): return time.strftime(MyLog.date, time.localtime(time.time()))class MyLog: path &#x3D; os.path.dirname(os.path.dirname(os.path.abspath(__file__))) log_file &#x3D; path + &#39;&#x2F;Log&#x2F;log.log&#39; err_file &#x3D; path + &#39;&#x2F;Log&#x2F;err.log&#39; logger.setLevel(LEVELS.get(level, logging.NOTSET)) create_file(log_file) create_file(err_file) date &#x3D; &#39;%Y-%m-%d %H:%M:%S&#39; # 创建一个handler，用于写入日志文件 handler &#x3D; logging.FileHandler(log_file, encoding&#x3D;&#39;utf-8&#39;) err_handler &#x3D; logging.FileHandler(err_file, encoding&#x3D;&#39;utf-8&#39;) @staticmethod def debug(log_meg): set_handler(&#39;debug&#39;) # 文件中输出模式 logger.debug(log_meg) remove_handler(&#39;debug&#39;) @staticmethod def info(log_meg): set_handler(&#39;info&#39;) logger.info(log_meg) remove_handler(&#39;info&#39;) @staticmethod def warning(log_meg): set_handler(&#39;warning&#39;) logger.warning(log_meg) remove_handler(&#39;warning&#39;) @staticmethod def error(log_meg): set_handler(&#39;error&#39;) logger.error(log_meg) remove_handler(&#39;error&#39;) @staticmethod def critical(log_meg): set_handler(&#39;critical&#39;) logger.error(log_meg) remove_handler(&#39;critical&#39;) # 设置控制台输出格式 formatter &#x3D; logging.Formatter(&quot;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&quot;) # 再创建一个handler，用于输出到控制台 console &#x3D; logging.StreamHandler() console.setFormatter(formatter) handler.setFormatter(formatter) err_handler.setFormatter(formatter) logger.addHandler(console) console.setLevel(logging.INFO)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: MyLog.debug(&quot;This is debug message&quot;) MyLog.info(&quot;This is info message&quot;) MyLog.warning(&quot;This is warning message&quot;) MyLog.error(&quot;This is error&quot;) MyLog.critical(&quot;This is critical message&quot;) unit.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from commom.handel_json import get_jsondatafrom commom.log import MyLogdef get_host(file_name): if file_name.find(&quot;ubq&quot;) &gt;&#x3D; 0: if file_name.find(&quot;_fe_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;ubq_fe_host&quot;] return host elif file_name.find(&quot;_be_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;ubq_be_host&quot;] return host else: # 此处应打印log日志记录无法在文件名中找到对应标志，文件名拼写错误 MyLog.debug(&quot;无法在文件名中找到端标识&quot;) return None elif file_name.find(&quot;mlm&quot;) &gt;&#x3D; 0: if file_name.find(&quot;_fe_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;mlm_fe_host&quot;] return host elif file_name.find(&quot;_be_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;mlm_be_host&quot;] return host else: MyLog.debug(&quot;无法在文件名中找到端标识&quot;) # 此处应打印log日志记录无法在文件名中找到对应标志，文件名拼写错误 return None elif file_name.find(&quot;gzb&quot;) &gt;&#x3D; 0: if file_name.find(&quot;_fe_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;gzb_fe_host&quot;] return host elif file_name.find(&quot;_be_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;gzb_be_host&quot;] return host elif file_name.find(&quot;_sh_&quot;) &gt;&#x3D; 0: host &#x3D; get_jsondata(&quot;config.json&quot;)[&quot;test&quot;][&quot;gzb_sh_host&quot;] return host else: MyLog.debug(&quot;无法在文件名中找到端标识&quot;) # 此处应打印log日志记录无法在文件名中找到对应标志，文件名拼写错误 return None else: # 此处应打印log日志记录无法在文件名中找到对应标志 MyLog.info(&quot;无法在文件名中找到系统标识，文件名错误&quot;) return Nonedef get_init_data(key): key &#x3D; key + &quot;_data&quot; data &#x3D; get_jsondata(&quot;config.json&quot;)[key] if data &#x3D;&#x3D; &#123;&#125;: MyLog.info(f&quot;无法获取到&#123;key&#125;对应的初始化账号数据&quot;) return None return datadef get_data(name): json_name &#x3D; name + &#39;.json&#39; json_data &#x3D; get_jsondata(json_name) mid_name &#x3D; name[5:11] headers &#x3D; get_jsondata(&#39;headers.json&#39;)[mid_name][&quot;headers&quot;] host &#x3D; get_host(json_name) url &#x3D; host + json_data[&#39;url&#39;] par &#x3D; json_data[&#39;testcase&#39;][0] return url, headers, par config config.json(数据相关已脱敏(◔‸◔）) 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;test&quot;: &#123; &quot;ubq_fe_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot;, &quot;ubq_be_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot;, &quot;ubq_sh_host&quot;: &quot;http:&#x2F;&#x2F;xxx&quot;, &quot;mlm_fe_host&quot;: &quot;http:&#x2F;&#x2F;xxx&quot;, &quot;mlm_be_host&quot;: &quot;http:&#x2F;&#x2F;xxx&quot;, &quot;gzb_be_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot;, &quot;gzb_sh_host&quot;: &quot;https:&#x2F;&#x2F;xxx&quot; &#125;, &quot;ubq_fe_host_data&quot;:&#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;ubq_be_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;ubq_sh_host_data&quot;: &#123; &#125;, &quot;mlm_fe_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;mlm_be_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxx&quot;, &quot;password&quot;:&quot;xxxx&quot; &#125;, &quot;gzb_be_host_data&quot;: &#123; &quot;user&quot;:&quot;xxxxx&quot;, &quot;password&quot;:&quot;xxxxx&quot; &#125;, &quot;gzb_sh_host_data&quot;: &#123; &#125;, &quot;login_path&quot;: &#123; &quot;path&quot;: &quot;&#x2F;xxxxx&#x2F;xxxx&quot; &#125;&#125; header.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; &quot;header&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot; &#125;, &quot;ubq_fe&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;ubq_be&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;ubq_sh&quot;: &#123; &quot;headers&quot;: &#123;&#125; &#125;, &quot;mlm_fe&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;mlm_be&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;gzb_fe&quot;: &#123; &quot;headers&quot;: &#123;&#125; &#125;, &quot;gzb_be&quot;: &#123; &quot;headers&quot;: &#123; &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;85.0.4183.121 Safari&#x2F;537.36&quot;, &quot;Accept&quot;: &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;, &quot;Content-Type&quot;: &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;, &quot;token&quot;: &quot;&quot; &#125; &#125;, &quot;gzb_sh&quot;: &#123; &quot;headers&quot;: &#123;&#125; &#125;&#125; data中的用例 12345678910111213141516171819&#123; &quot;name&quot;:&quot;项目名&quot;, &quot;url&quot;:&quot;&#x2F;xxxx&#x2F;xxxxx&#x2F;xxxx&#x2F;xxxx&quot;, &quot;method&quot;:&quot;GET&quot;, &quot;testcase&quot;:[ &#123; &quot;name&quot;:&quot;用例名&quot;, &quot;params&quot;:&#123; &quot;demoid&quot;:&quot;xxxxxxxxxxxxxxxx&quot; &#125;, &quot;validate&quot;: &#123; &quot;success&quot;:&quot;True&quot;, &quot;data&quot;: &#123; &quot;xxxxx&quot;: &quot;xxxxx&quot; &#125; &#125; &#125; ]&#125; test:通过函数名来确定对应的用例 1234567891011121314from commom.unit import get_dataimport requestsimport sysimport allureclass Test(object): @allure.feature(&#39;验证漫联盟管理系统存证详情&#39;) def test_mlm_be_evidenceDetail(self): url, headers, par &#x3D; get_data(sys._getframe().f_code.co_name) r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, params&#x3D;par[&#39;params&#39;]) response &#x3D; r.json() assert r.status_code &#x3D;&#x3D; 200 assert str(response[&quot;success&quot;]) &#x3D;&#x3D; par[&#39;validate&#39;][&#39;success&#39;] conftst.py pytest的fixtue功能，可对接口验证进行前后置操作 1234567891011121314151617181920import pytestfrom commom.unit import get_dataimport requestsimport json@pytest.fixture(scope&#x3D;&quot;class&quot;)def del_car(): &quot;&quot;&quot; 后置删除购物车添加 :return: &quot;&quot;&quot; yield url, headers, par &#x3D; get_data(&quot;test_mlm_fe_list&quot;) r &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, params&#x3D;par[&#39;params&#39;]) response &#x3D; r.json() ids &#x3D; response[&#39;data&#39;][0][&#39;shoppingCartProductVOS&#39;][0][&#39;id&#39;] data &#x3D; &#123;&quot;ids&quot;:[int(ids)]&#125; url, headers, par &#x3D; get_data(&quot;test_mlm_fe_delete&quot;) res &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;json.dumps(data)) return del_car pytest.ini pytest的配置控制台不显示乱码 12[pytest]disable_test_id_escaping_and_forfeit_all_rights_to_community_support &#x3D; True run.py 123456789101112131415&quot;&quot;&quot;主程序入口&quot;&quot;&quot;import pytestfrom commom.handel_cookie import handel_token, clearif __name__ &#x3D;&#x3D; &#39;__main__&#39;: &quot;&quot;&quot; 1.清理配置信息 1.获取token，存储到cookie.json中供全局使用 &quot;&quot;&quot; clear() handel_token() pytest.main([&#39;-s&#39;, &#39;-q&#39;, &#39;--alluredir&#x3D;allure_results&#39;])","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"pytest","slug":"pytest","permalink":"http://example.com/tags/pytest/"}],"author":"H·stone"},{"title":"allure测试报告在项目中的使用实践","slug":"report","date":"2021-01-22T10:11:56.000Z","updated":"2021-01-22T08:36:35.243Z","comments":true,"path":"2021/01/22/report/","link":"","permalink":"http://example.com/2021/01/22/report/","excerpt":"","text":"allure测试报告在自动化项目中的使用Allure Framework是一种灵活的轻量级多语言测试报告工具，美观且功能丰富 使用allure报告的前置条件 下载安装jdk，并配置好环境变量 下载allure安装包解压到文件夹（任意即可），并配置环境变量 pip install allure-pytest 使用： 运行项目时执行，指定生成的allure文件存放的文件夹 123456789if __name__ &#x3D;&#x3D; &#39;__main__&#39;: &quot;&quot;&quot; 1.清理配置信息 1.获取token，存储到cookie.json中供全局使用 &quot;&quot;&quot; clear() handel_token() pytest.main([&#39;-s&#39;, &#39;-q&#39;, &#39;--alluredir&#x3D;allure_results&#39;]) allure_results文件夹中生成了一堆json，txt等格式的莫名文件 1allure serve allure_results执行后会调起浏览器展示测试报告 此处需注意，只能使用火狐浏览器 1234567(venv) C:\\Users\\Administrator\\Desktop\\autotestAPI&gt;allure serve allure_resultsGenerating report to temp directory...Report successfully generated to C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\2357441130466454662\\allure-reportStarting web server...2021-01-22 15:42:06.658:INFO::main: Logging initialized @2962ms to org.eclipse.jetty.util.log.StdErrLogServer started at &lt;http:&#x2F;&#x2F;192.168.0.101:5948&#x2F;&gt;. Press &lt;Ctrl+C&gt; to exit","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"allure","slug":"allure","permalink":"http://example.com/tags/allure/"}],"author":"H·stone"},{"title":"盐","slug":"hee","date":"2021-01-18T11:11:30.000Z","updated":"2021-01-21T06:06:29.362Z","comments":true,"path":"2021/01/18/hee/","link":"","permalink":"http://example.com/2021/01/18/hee/","excerpt":"","text":"遇上了一个账号需要改动密码，直接在数据库中改动了，发现无法登录，询问后端才知道，密码并不是简单的，直接sha256哈希userid出来的，经过了三重updata的拼接。python复现↓ 12345678910import hashlibuserID &#x3D; &#39;788802624700001609839882&#39;passWord &#x3D; &#39;f379eaf3c831b04de153469d1bec345e&#39;sha &#x3D; hashlib.sha256()sha.update(userID.encode(&#39;UTF-8&#39;))sha.update(passWord.encode(&#39;UTF-8&#39;))sha.update(userID.encode(&#39;UTF-8&#39;))print(sha.hexdigest()) 但是这个还有bug，哈希过程中并未加盐，hacker可以通过彩虹表反推，得到密码。 注册功能一般在数据库中存放的密码都是经过加密 简单的加密就是直接 sha256等等 ，但是如果通过彩虹表反推，是有可能被破解的。 所以一般会在生成 hash码的时候 加盐。 盐：出于预先防止黑客利用彩虹表反推盗用用户的密码账户信息，就需要给密码加‘盐’，其实简单来说，就是在hashlib模块中的md5加密方法时，传入一个你自己想给的盐，或者干脆随机生成（比较安全，将盐封装在类中） 彩虹表：彩虹表是一个用于加密散列函数逆运算的预先计算好的表, 为破解密码的散列值（或称哈希值、微缩图、摘要、指纹、哈希密文）而准备。一般主流的彩虹表都在100G以上。 这样的表常常用于恢复由有限集字符组成的固定长度的纯文本密码 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839import hashlib,random#注册storage&#x3D;&#123;&#125;def registration(u,p): if u in storage: return &#39;username occupied.please choose another username...&#39; else: storage[u]&#x3D;Users(u,p)#加密方法def get_md5(s): return hashlib.md5(s.encode(&#39;utf-8&#39;)).hexdigest()#登陆class Users(object): def __init__(self,username,password): self.username&#x3D;username #!!!!!!!注意盐是随机给的，每注册一个账号给一次盐，封装在Users类里面，在login函数里比较相等时， # a.salt是注册时封装好的盐，这时是固定的盐，所以只要账号密码对了就可以了。 self.salt&#x3D;&#39;&#39;.join([chr(random.randint(48,122)) for i in range(20)]) self.password&#x3D;get_md5(password+self.salt)def login(user,pw): if user not in storage.keys(): return &#39;wrong username&#39; else: a&#x3D;storage[user] if a.password&#x3D;&#x3D;get_md5(pw+a.salt): return &#39;succeeded&#39; else: return &#39;wrong password&#39;registration(&#39;mary&#39;,&#39;12345&#39;)registration(&#39;bob&#39;,&#39;aa895&#39;)registration(&#39;kirk&#39;,&#39;ba155&#39;)print(storage)print(login(&#39;mary&#39;,&#39;12345&#39;))","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"sha256","slug":"sha256","permalink":"http://example.com/tags/sha256/"}],"author":"H·stone"},{"title":"尝试Monkey测试","slug":"Monkeytest","date":"2020-09-17T01:56:26.000Z","updated":"2021-01-25T08:08:32.599Z","comments":true,"path":"2020/09/17/Monkeytest/","link":"","permalink":"http://example.com/2020/09/17/Monkeytest/","excerpt":"","text":"因为业务的关系一直聚焦于功能测试，接口测试，还没有尝试过跑Monkey脚本，试了一试。 参考： https://ww.cnblogs.com/lauren1003/p/6193277.html https://www.cnblogs.com/tekoyo/p/5288661.html 实践：monkey测试 首要条件：安装JDK 安装SDK 连接模拟器 –连接模拟器 mumu模拟器 1adb connect 127.0.0.1:7555 –查询应用程序 1adb shell dumpsys activity|find &quot;mFocusedActivity&quot; –点击1000下 1adb shell monkey -p com.thgy.uprotect 1000 –点击并生成日志 1adb shell monkey -p com.thgy.uprotect -s 500 --ignore-crashes --ignore-timeouts --monitor-native-crashes -v -v -v 10000 &gt; D:\\monkey.txt","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Monkey","slug":"Monkey","permalink":"http://example.com/tags/Monkey/"}],"author":"H·stone"},{"title":"弱网测试","slug":"weaknet","date":"2019-04-16T10:11:56.000Z","updated":"2021-01-21T05:51:00.695Z","comments":true,"path":"2019/04/16/weaknet/","link":"","permalink":"http://example.com/2019/04/16/weaknet/","excerpt":"","text":"ios弱网配置操作步骤： 进入开发者选项 选择NETWORK LINK CONDITIONER 将ENABLE打开 选择对应的网络环境，100%Loss、3G、Very Bad Network、WiFi等 自定义网络环境：Add a profile 备注：bandwidth是带宽，以k/s为单位；packet loss是丢包率，按百分比计算；delay延时，单位是毫秒，1000毫秒等于1秒。下面是我配的几个参考网络环境。 有的可以采用无线热点进行限速 charles如何设置弱网","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"弱网测试","slug":"弱网测试","permalink":"http://example.com/tags/%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/"}],"author":"H·stone"},{"title":"selenium中曾经遇上问题的地方","slug":"selenium","date":"2019-01-29T06:43:12.000Z","updated":"2021-01-25T10:14:36.378Z","comments":true,"path":"2019/01/29/selenium/","link":"","permalink":"http://example.com/2019/01/29/selenium/","excerpt":"","text":"关于元素互相遮挡元素块互有遮挡 会造成 click（）某个元素的时候，点击不到想要的元素 点击到别的地方去。 123sub_loc &#x3D; &#39;&#x2F;html&#x2F;body&#x2F;div[2]&#39;sub &#x3D; bp.By_xpath(sub_loc)driver.execute_script(&#39;$(arguments[0]).fadeOut()&#39;, sub) 直接找到遮盖了目标元素的元素块，直接隐藏。 显示/隐式等待隐式等待当查找元素没有立即出现的时候，隐式等待等待一段时间后再查找DOM，默认时间是0 123456from selenium import webdriverbrowser &#x3D; webdriver.Chrome()browser.implicitly_wait(10)browser.get(&quot;http:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&quot;)input &#x3D; browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input) 显式等待指定一个等待条件，设置一个最长等待时间等带时间内满足了条件就正常返回 1234567891011121314from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser &#x3D; webdriver.Chrome()browser.get(&quot;http:&#x2F;&#x2F;www.taobao.com&#x2F;&quot;)wait &#x3D; WebDriverWait(browser,10)input &#x3D; wait.until(EC.presence_of _element_located((By.ID,&#39;q&#39;)))button &#x3D; wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR,&#39;.btn-search&#39;)))print(input,button)​ def ByXpath_wait_time(self, loc_arg): &quot;&quot;&quot;元素获取方式之xpath-显示等待&quot;&quot;&quot; return WebDriverWait(self.driver, 15, 3).until(EC.presence_of_element_located((By.XPATH, loc_arg))) 执行javascript123456from selenium import webdriver​browser &#x3D; webdriver.Chrome()browser.get(&quot;http:&#x2F;&#x2F;www.taobao.com&#x2F;&quot;)browser.execute_script(&#39;window.scrollTo(0,document.body.scrollHeight)&#39;)browser.execute_script(&#39;alert(&quot;To Bottom&quot;)&#39;) #实现了页面从上到下拉​ chrome无头模式123chrome_options &#x3D; Options() chrome_options.add_argument(&#39;--headless&#39;) driver &#x3D; webdriver.Chrome(chrome_options&#x3D;chrome_options) selenium对于alert的处理（坑）1234567try: WebDriverWait(driver, 5).until(EC.alert_is_present(), &#39;Timed out waiting for alerts to appear&#39;) alert &#x3D; driver.switch_to.alert alert.accept() print(&quot;alert accepted&quot;) except TimeoutException: print(&quot;no alert&quot;) ==不是所有alert警告都是弹窗后瞬间警告，需要加上等待==","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"http://example.com/tags/selenium/"},{"name":"ui自动化","slug":"ui自动化","permalink":"http://example.com/tags/ui%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"author":"H·stone"}],"categories":[{"name":"韭菜日记","slug":"韭菜日记","permalink":"http://example.com/categories/%E9%9F%AD%E8%8F%9C%E6%97%A5%E8%AE%B0/"},{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"stock","slug":"stock","permalink":"http://example.com/tags/stock/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"pytest","slug":"pytest","permalink":"http://example.com/tags/pytest/"},{"name":"allure","slug":"allure","permalink":"http://example.com/tags/allure/"},{"name":"sha256","slug":"sha256","permalink":"http://example.com/tags/sha256/"},{"name":"Monkey","slug":"Monkey","permalink":"http://example.com/tags/Monkey/"},{"name":"弱网测试","slug":"弱网测试","permalink":"http://example.com/tags/%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/"},{"name":"selenium","slug":"selenium","permalink":"http://example.com/tags/selenium/"},{"name":"ui自动化","slug":"ui自动化","permalink":"http://example.com/tags/ui%E8%87%AA%E5%8A%A8%E5%8C%96/"}]}